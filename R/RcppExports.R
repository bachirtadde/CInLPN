# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Function that computes the log-likelihood of the observed data
#'  
#' @param K an integer indicating the number of markers
#' @param nD an integer indicating the number of latent processes
#' @param mapping indicates which outcome measured which latent process, it is a mapping table between
#' outcomes and latents processes
#' @param paraOpt initial values for model parameters
#' @param paraFixe values associated to the index of parameters to be constrained
#' @param posfix position of parameters to be constrained
#' @param m_is vector of numbers of visit occasions for individuals
#' @param Mod_MatrixY model.matrix from markers transformation submodels
#' @param Mod_MatrixYprim model.matrix from the derivates of markers transformation submodels
#' @param df vector of numbers of parameters for each transformation model
#' @param nb_paraD number of paramerters of the variance-covariance matrix of random effects
#' @param x0 model.matrix for baseline's fixed submodel
#' @param x model.matrix for change's fixed submodel
#' @param z0 model.matrix for baseline's random effects submodel
#' @param z model.matrix for change's random effects submodel
#' @param q0 a vector of number of random effects on each initial latent process level
#' @param q a vector of number of random effects on each change latent process over time
#' @param if_link indicates if non linear link is used to transform an outcome
#' @param tau a vector of integers indicating times (including maximum time)
#' @param tau_is a vector of integers indicating times for individuals
#' @param modA_mat model.matrix for elements of the transistion matrix
#' @param DeltaT double that indicates the discretization step  
#' 
#' @return double 
#' @export
#' 
Loglik <- function(K, nD, mapping, paraOpt, paraFixe, posfix, m_is, Mod_MatrixY, Mod_MatrixYprim, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT) {
    .Call(`_CInLPN_Loglik`, K, nD, mapping, paraOpt, paraFixe, posfix, m_is, Mod_MatrixY, Mod_MatrixYprim, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT)
}

#' Function that computes the fits (marginal and subject-specific) for individuals. That is 
#' observations are available and from them, fits will be compute from the model. The difference 
#' between fits and predictions is that, for predictions there is no observation where as for 
#' fit observations are available.
#'  
#' @param K an integer indicating the number of markers
#' @param nD an integer indicating the number of latent processes
#' @param mapping indicates which outcome measured which latent process, it is a mapping table between
#' outcomes and latents processes
#' @param paras values of model parameters
#' @param m_is vector of numbers of visit occasions for individuals
#' @param Mod_MatrixY model.matrix from markers transformation submodels
#' @param df vector of numbers of parameters for each transformation model
#' @param nb_paraD number of paramerters of the variance-covariance matrix of random effects
#' @param x0 model.matrix for baseline's fixed submodel
#' @param x model.matrix for change's fixed submodel
#' @param z0 model.matrix for baseline's random effects submodel
#' @param z model.matrix for change's random effects submodel
#' @param q0 a vector of number of random effects on each initial latent process level
#' @param q a vector of number of random effects on each change latent process over time
#' @param if_link indicates if non linear link is used to transform an outcome
#' @param tau a vector of integers indicating times (including maximum time)
#' @param tau_is a vector of integers indicating times for individuals
#' @param modA_mat model.matrix for elements of the transistion matrix
#' @param DeltaT double that indicates the discretization step  
#' @param MCnr an integer that indicates the number of sample for MC method  
#' @param minY a vector of minima of outcomes
#' @param maxY a vector of maxima of outcomes
#' @param knots indicates position of knots used to transform outcomes
#' @param degree indicates degree of the basis of splines
#' @param epsPred convergence criteria for prediction using MC method
#' 
#' @return a matrix
#' @export
#' 
fit <- function(K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred) {
    .Call(`_CInLPN_fit`, K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred)
}

#' Function that computes the predictions (marginal and subject-specific) for individuals
#'  
#' @param K an integer indicating the number of markers
#' @param nD an integer indicating the number of latent processes
#' @param mapping indicates which outcome measured which latent process, it is a mapping table between
#' outcomes and latents processes
#' @param paras values of model parameters
#' @param m_is vector of numbers of visit occasions for individuals
#' @param Mod_MatrixY model.matrix from markers transformation submodels
#' @param df vector of numbers of parameters for each transformation model
#' @param nb_paraD number of paramerters of the variance-covariance matrix of random effects
#' @param x0 model.matrix for baseline's fixed submodel
#' @param x model.matrix for change's fixed submodel
#' @param z0 model.matrix for baseline's random effects submodel
#' @param z model.matrix for change's random effects submodel
#' @param q0 a vector of number of random effects on each initial latent process level
#' @param q a vector of number of random effects on each change latent process over time
#' @param if_link indicates if non linear link is used to transform an outcome
#' @param tau a vector of integers indicating times (including maximum time)
#' @param tau_is a vector of integers indicating times for individuals
#' @param modA_mat model.matrix for elements of the transistion matrix
#' @param DeltaT double that indicates the discretization step  
#' @param MCnr an integer that indicates the number of sample for MC method  
#' @param minY a vector of minima of outcomes
#' @param maxY a vector of maxima of outcomes
#' @param knots indicates position of knots used to transform outcomes
#' @param degree indicates degree of the basis of splines
#' @param epsPred convergence criteria for prediction using MC method
#' 
#' @return a matrix
#' @export
#' 
pred <- function(K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred) {
    .Call(`_CInLPN_pred`, K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred)
}

#' Function that vectorises a matrix by rows
#' 
#' @param M a matrix
#' @export
vectorise <- function(M) {
    .Call(`_CInLPN_vectorise`, M)
}

#' Function that creates a K-block diagonal matrix with non diagonal element fixed to 0
#' 
#' @param Kvector a vector of length K
#' 
#' @return a diagonal matrix
#' @export
#' 
KmatDiag <- function(Kvector) {
    .Call(`_CInLPN_KmatDiag`, Kvector)
}

#'  Function that computes a symetric D matric from it Cholesky L
#'  
#' @param q an integer
#' @param qvector a vector of length q
#' 
#' @return a symetric positive define matrix
#' @export
#' 
DparChol <- function(q, qvector) {
    .Call(`_CInLPN_DparChol`, q, qvector)
}

#'  Function that computes all coefficients of the transition matrix at time t
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t an integer indicating the time at which coefficients are computed 
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a vector of elements of the transition matrix
#' @export
#' 
vecaijt <- function(K, t, vec_alpha_ij, modA_mat) {
    .Call(`_CInLPN_vecaijt`, K, t, vec_alpha_ij, modA_mat)
}

#'  Function that  constructs the transition matrix at time t
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t an integer indicating the time at which coefficients are computed 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return Id + DeltaT*A where A is the transition matrix
#' @export
#' 
ConstrA <- function(K, t, DeltaT, vec_alpha_ij, modA_mat) {
    .Call(`_CInLPN_ConstrA`, K, t, DeltaT, vec_alpha_ij, modA_mat)
}

#'  Function that  creates a matrix K,K*(max(tau_i)-1) containing  sub-matrices {(A_t)}_{t=0,tau_i-1}
#'  
#' @param K an integer representing the size of K*K matrix
#' @param tau_i vector of integers indicating times at which coefficients are computed 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix containing matrix of form Id + DeltaT*A
#' @export
#' 
GmatA0totaui <- function(K, vec_alpha_ij, tau_i, DeltaT, modA_mat) {
    .Call(`_CInLPN_GmatA0totaui`, K, vec_alpha_ij, tau_i, DeltaT, modA_mat)
}

#'  Function that  computes the product of A(t) for t1 to t2
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t1 indicates the started discretized time
#' @param t2 indicates the ended discretized time
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix
#' @export
#' 
ProdA <- function(K, t2, t1, DeltaT, vec_alpha_ij, modA_mat) {
    .Call(`_CInLPN_ProdA`, K, t2, t1, DeltaT, vec_alpha_ij, modA_mat)
}

#'  Function that  creates a big matrix containing  Prod(A_t)t=t_ini,tau.
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t_ini indicates the started discretized time
#' @param tau vector of integers indicating times 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix
#' @export
#' 
GmatprodAstotau <- function(K, vec_alpha_ij, tau, t_ini, DeltaT, modA_mat) {
    .Call(`_CInLPN_GmatprodAstotau`, K, vec_alpha_ij, tau, t_ini, DeltaT, modA_mat)
}

#'  Function that  creates a big matrix ts_G_mat_prod_A_0_to_tau containing  Prod(A_t)t=0,tau.
#'  
#' @param K an integer representing the size of K*K matrix
#' @param tau vector of integers indicating times 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix
#' @export
#' 
tsGmatprodA0totau <- function(K, vec_alpha_ij, tau, DeltaT, modA_mat) {
    .Call(`_CInLPN_tsGmatprodA0totau`, K, vec_alpha_ij, tau, DeltaT, modA_mat)
}

#' After vectorising the vzector Yi, this function returns
#' a vector indicating missing values : 1 = observed value, 0 = missing value
#' 
#' @param Yi a matrix with possibly NAs
#' 
#' @return a vector of elements 0,1
#' @export
#' 
compoYiNA <- function(Yi) {
    .Call(`_CInLPN_compoYiNA`, Yi)
}

#' Function that returns Yi (a vector) without NAs values
#' 
#' @param Yi a vector with possibly NAs
#' 
#' @return a vector 
#' @export
#' 
YiwoNA <- function(Yi) {
    .Call(`_CInLPN_YiwoNA`, Yi)
}

#'  Function that constructs the matrix nu_t_j, the expectation of the processes at time t_j
#'  
#' @param nD an integer indicating the number of processes
#' @param tau_i vector of integers indicating times 
#' @param DeltaT double that indicates the discretization step
#' @param x0i model.matrix for baseline's submodel
#' @param xi model.matrix for change's submodel
#' @param alpha_mu0 a vector of parameters associated to the model.matrix for the baseline's submodel
#' @param alpha_mu a vector of parameters associated to the model.matrix for the change's submodel
#' @param G_mat_A_0_to_tau_i matrix containing  Prod(A_t)t=0,tau_i where A_t is the transition
#' matric containing at time t
#' 
#' @return a matrix
#' @export
#' 
matNui <- function(nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i) {
    .Call(`_CInLPN_matNui`, nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i)
}

#' Function that replaces NAs by 0.0 just for computatinal need
#' 
#' @param Yi a matrix with possibly NAs
#' 
#' @return a matrix 
#' @export
#' 
f_Yi_r_NA_by0 <- function(Yi) {
    .Call(`_CInLPN_f_Yi_r_NA_by0`, Yi)
}

#' Function that computes the difference (mat_Yi - mat_Nu_i), delates missing values (NAs) and 
#' returns a vector. mat_Yi is the outcomes and mat_Nu_i is the expectation
#'  
#' @param nD an integer indicating the number of processes
#' @param matrixP a matrix that matches markers to latent processes
#' @param tau a vector of integers indicating times 
#' @param tau_i a vector of integers indicating times for individual i
#' @param DeltaT double that indicates the discretization step
#' @param Yi a matrix of the outcomes
#' @param x0i model.matrix for baseline's submodel
#' @param xi model.matrix for change's submodel
#' @param alpha_mu0 a vector of parameters associated to the model.matrix for the baseline's submodel
#' @param alpha_mu a vector of parameters associated to the model.matrix for the change's submodel
#' @param G_mat_A_0_to_tau_i matrix containing  Prod(A_t)t=0,tau_i where A_t is the transition
#' matric containing at time t
#' 
#' @return a vector
#' @export
#' 
YiNui <- function(nD, matrixP, tau, tau_i, DeltaT, Yi, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i) {
    .Call(`_CInLPN_YiNui`, nD, matrixP, tau, tau_i, DeltaT, Yi, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i)
}

#' Function that transforms a vector to a matrix
#' 
#' @param y a vector 
#' @param K an integer indicating the number of columns of the returned matrix
#' @param m_i an integer indicating the number of rows of the returned matrix
#' 
#' @return a matrix 
#' @export
#' 
VecToMat <- function(y, K, m_i) {
    .Call(`_CInLPN_VecToMat`, y, K, m_i)
}

